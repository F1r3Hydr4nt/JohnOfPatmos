#!/usr/bin/env python3
"""
Find Cast-128 S-boxes in binary and generate GDB commands to monitor them.
"""

import subprocess
import re
import sys
import os

# Cast-128 S-box signatures (first few entries of each S-box)
# These are the standard Cast-128 S-boxes from the specification
SBOX_SIGNATURES = {
    'S1': [0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a],
    'S2': [0x1f213f8b, 0x2787e90a, 0x4e5ecee7, 0x6b71e493],
    'S3': [0x8cb5e2d2, 0x742e1e8b, 0xefc8e2f6, 0x2c3f9b76],
    'S4': [0x9d7a4d76, 0xd0fe1a9f, 0x683f1b0e, 0xa4206b8e],
    'S5': [0x3d68b05e, 0xf642bf0d, 0xe8c5cd2f, 0x91a6c88c],
    'S6': [0x7ec1bbce, 0x78ef7f3f, 0x1cbfcaa6, 0x1c970440],
    'S7': [0x38e0a600, 0xc3123bf7, 0x2fb06b23, 0x7dc83483],
    'S8': [0x93ac204f, 0x6defef93, 0x3e0f9f77, 0x2f032046]
}

def find_sbox_in_binary(elf_file, sbox_name, signature):
    """Find S-box location in ELF file using objdump."""
    try:
        # Dump all sections
        cmd = f"objdump -s {elf_file}"
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"Error running objdump: {result.stderr}")
            return None
        
        # Convert signature to hex string pattern
        hex_pattern = ''.join([f'{val:08x}' for val in signature[:2]])
        
        # Search for pattern in output
        lines = result.stdout.split('\n')
        for i, line in enumerate(lines):
            if hex_pattern[:8].lower() in line.lower():
                # Extract address from line
                match = re.match(r'\s*([0-9a-f]+)\s', line)
                if match:
                    addr = int(match.group(1), 16)
                    print(f"Found {sbox_name} at 0x{addr:08x}")
                    return addr
        
        # Alternative: search for little-endian representation
        hex_pattern_le = ''.join([f'{((val>>24)&0xff):02x}{((val>>16)&0xff):02x}{((val>>8)&0xff):02x}{(val&0xff):02x}' 
                                  for val in signature[:2]])
        
        for i, line in enumerate(lines):
            if hex_pattern_le[:8] in line.lower():
                match = re.match(r'\s*([0-9a-f]+)\s', line)
                if match:
                    addr = int(match.group(1), 16)
                    print(f"Found {sbox_name} at 0x{addr:08x} (little-endian)")
                    return addr
                    
    except Exception as e:
        print(f"Error searching for {sbox_name}: {e}")
    
    return None

def find_sbox_in_symbols(elf_file):
    """Look for S-box related symbols."""
    try:
        cmd = f"nm -a {elf_file} | grep -i 's[1-8]\\|sbox\\|cast5'"
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        
        if result.stdout:
            print("\nFound S-box related symbols:")
            print(result.stdout)
            
            sbox_addrs = {}
            for line in result.stdout.split('\n'):
                if line:
                    parts = line.split()
                    if len(parts) >= 3:
                        addr = parts[0]
                        symbol = parts[-1]
                        # Look for S1-S8 patterns
                        for i in range(1, 9):
                            if f's{i}' in symbol.lower() or f'S{i}' in symbol:
                                sbox_addrs[f'S{i}'] = int(addr, 16)
                                print(f"  S{i}: 0x{addr}")
            
            return sbox_addrs
    except Exception as e:
        print(f"Error searching symbols: {e}")
    
    return {}

def generate_gdb_commands(sbox_addresses, output_file):
    """Generate GDB commands to monitor S-boxes."""
    
    with open(output_file, 'w') as f:
        f.write("# GDB Commands for Monitoring Cast-128 S-boxes\n")
        f.write("# Generated by find_sboxes.py\n\n")
        
        # Add Python monitoring functions
        f.write("python\n")
        f.write("import gdb\n\n")
        
        f.write("# Store original S-box values\n")
        f.write("sbox_original = {}\n")
        f.write("sbox_addresses = {\n")
        for name, addr in sbox_addresses.items():
            f.write(f"    '{name}': 0x{addr:08x},\n")
        f.write("}\n\n")
        
        f.write("def save_sbox_values():\n")
        f.write("    \"\"\"Save current S-box values as reference.\"\"\"\n")
        f.write("    global sbox_original\n")
        f.write("    for name, addr in sbox_addresses.items():\n")
        f.write("        try:\n")
        f.write("            # Read first 32 bytes of each S-box\n")
        f.write("            values = []\n")
        f.write("            for i in range(8):\n")
        f.write("                val = gdb.parse_and_eval(f'*(int*)(0x{addr:x} + {i*4})')\n")
        f.write("                values.append(int(val))\n")
        f.write("            sbox_original[name] = values\n")
        f.write("            print(f'Saved {name} values')\n")
        f.write("        except Exception as e:\n")
        f.write("            print(f'Error saving {name}: {e}')\n\n")
        
        f.write("def check_sbox_integrity():\n")
        f.write("    \"\"\"Check if S-boxes have been modified.\"\"\"\n")
        f.write("    corrupted = False\n")
        f.write("    for name, addr in sbox_addresses.items():\n")
        f.write("        if name not in sbox_original:\n")
        f.write("            continue\n")
        f.write("        try:\n")
        f.write("            for i in range(8):\n")
        f.write("                current = int(gdb.parse_and_eval(f'*(int*)(0x{addr:x} + {i*4})'))\n")
        f.write("                if current != sbox_original[name][i]:\n")
        f.write("                    print(f'\\n*** S-BOX CORRUPTION DETECTED in {name}!')\n")
        f.write("                    print(f'    Word {i}: 0x{sbox_original[name][i]:08x} -> 0x{current:08x}')\n")
        f.write("                    corrupted = True\n")
        f.write("        except Exception as e:\n")
        f.write("            print(f'Error checking {name}: {e}')\n")
        f.write("    if not corrupted:\n")
        f.write("        print('All S-boxes intact')\n")
        f.write("    return corrupted\n\n")
        
        f.write("# Save initial values\n")
        f.write("save_sbox_values()\n")
        f.write("end\n\n")
        
        # Set read watchpoints on S-boxes
        f.write("# Set read watchpoints on S-box access\n")
        watch_count = 0
        max_watches = 4  # Hardware limitation
        
        for name, addr in sbox_addresses.items():
            if watch_count < max_watches:
                f.write(f"# Monitor {name} access\n")
                f.write(f"rwatch *(int*)0x{addr:08x}\n")
                f.write("commands\n")
                f.write("  silent\n")
                f.write(f"  printf \"\\n[S-BOX ACCESS] {name} read at PC=%x\\n\", $pc\n")
                f.write("  python check_sbox_integrity()\n")
                f.write("  continue\n")
                f.write("end\n\n")
                watch_count += 1
        
        # Define convenience commands
        f.write("# Convenience commands\n")
        f.write("define check-sboxes\n")
        f.write("  python check_sbox_integrity()\n")
        f.write("end\n\n")
        
        f.write("define show-sbox\n")
        f.write("  if $argc == 0\n")
        f.write("    printf \"Usage: show-sbox <1-8>\\n\"\n")
        f.write("  else\n")
        
        for i in range(1, 9):
            if f'S{i}' in sbox_addresses:
                addr = sbox_addresses[f'S{i}']
                f.write(f"    if $arg0 == {i}\n")
                f.write(f"      printf \"S{i} at 0x{addr:08x}:\\n\"\n")
                f.write(f"      x/64wx 0x{addr:08x}\n")
                f.write(f"    end\n")
        
        f.write("  end\n")
        f.write("end\n\n")
        
        f.write("define monitor-sbox-writes\n")
        f.write("  printf \"Setting write watchpoints on S-boxes...\\n\"\n")
        for name, addr in list(sbox_addresses.items())[:2]:  # Only first 2 due to HW limits
            f.write(f"  watch *(int*)0x{addr:08x}\n")
        f.write("end\n\n")
        
        f.write("printf \"\\n\"\n")
        f.write("printf \"Cast-128 S-box Monitor Loaded\\n\"\n")
        f.write("printf \"Commands:\\n\"\n")
        f.write("printf \"  check-sboxes       - Check S-box integrity\\n\"\n")
        f.write("printf \"  show-sbox <1-8>    - Display S-box contents\\n\"\n")
        f.write("printf \"  monitor-sbox-writes - Set write watchpoints\\n\"\n")
        f.write("printf \"\\n\"\n")

def main():
    if len(sys.argv) < 2:
        print("Usage: find_sboxes.py <elf_file> [output.gdb]")
        sys.exit(1)
    
    elf_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else "sbox_monitor.gdb"
    
    if not os.path.exists(elf_file):
        print(f"Error: {elf_file} not found")
        sys.exit(1)
    
    print(f"Searching for Cast-128 S-boxes in {elf_file}...")
    
    # Method 1: Search for symbols
    print("\n1. Searching symbols...")
    symbol_addrs = find_sbox_in_symbols(elf_file)
    
    # Method 2: Search for known patterns
    print("\n2. Searching for S-box patterns...")
    pattern_addrs = {}
    for name, signature in SBOX_SIGNATURES.items():
        addr = find_sbox_in_binary(elf_file, name, signature)
        if addr:
            pattern_addrs[name] = addr
    
    # Combine results
    all_addrs = {**symbol_addrs, **pattern_addrs}
    
    if not all_addrs:
        print("\nNo S-boxes found automatically.")
        print("You may need to find them manually in GDB using:")
        print("  (gdb) find /w 0x08000000, 0x50000000, 0x30fb40d4")
        print("\nOr check the disassembly around the Cast5 functions.")
    else:
        print(f"\nFound {len(all_addrs)} S-boxes")
        print(f"Generating GDB commands in {output_file}...")
        generate_gdb_commands(all_addrs, output_file)
        print(f"Done! Load in GDB with: source {output_file}")

if __name__ == '__main__':
    main()

